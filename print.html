<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Kubewarden Kubernetes Policy Engine</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="quick-start.html"><strong aria-hidden="true">2.</strong> Quick Start</a></li><li class="chapter-item expanded "><a href="testing-policies.html"><strong aria-hidden="true">3.</strong> Testing Policies</a></li><li class="chapter-item expanded "><a href="writing-policies/index.html"><strong aria-hidden="true">4.</strong> Writing Policies</a></li><li class="chapter-item expanded "><a href="distributing-policies.html"><strong aria-hidden="true">5.</strong> Distributing Policies</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Kubewarden Kubernetes Policy Engine</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <blockquote>
<p><strong>WARNING:</strong> Kubewarden is in early development stage, it's not production ready.</p>
<p>Feedback is highly appreciated.</p>
</blockquote>
<h1><a class="header" href="#introduction" id="introduction">Introduction</a></h1>
<p>Kubewarden is a <a href="https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/">Kubernetes Dynamic Admission
Controller</a>
that validates incoming requests using policies written in
WebAssembly.</p>
<h2><a class="header" href="#what-is-webassembly" id="what-is-webassembly">What is WebAssembly?</a></h2>
<p>As stated on <a href="https://webassembly.org/">WebAssembly's official
website</a>:</p>
<blockquote>
<p>WebAssembly (abbreviated Wasm) is a binary instruction format for a
stack-based virtual machine. Wasm is designed as a portable
compilation target for programming languages, enabling deployment on
the web for client and server applications.</p>
</blockquote>
<p>WebAssembly has been originally conceived as an &quot;extension&quot; of
browsers. However, recent efforts have been made by the WebAssembly
community to allow the execution of WebAssembly code outside of
browsers.</p>
<h2><a class="header" href="#why-use-webassembly" id="why-use-webassembly">Why use WebAssembly?</a></h2>
<p>By using WebAssembly, users can write Kubernetes policies using their
favorite programming language, as long as the language can produce
Wasm binaries.</p>
<p>Policy authors can reuse their skills, tools and best
practices. Policies are &quot;traditional&quot; programs that can have reusable
blocks (regular libraries), can be tested, can be linted, can be
plugged into their current CI and CD workflows,...</p>
<p>Wasm modules are portable, once built they can run on any kind of
processor architecture and Operating System. A policy built on a Apple
Silicon machine can be run on a x86_64 Linux server without any
conversion.</p>
<h2><a class="header" href="#policy-distribution" id="policy-distribution">Policy distribution</a></h2>
<p>Kubewarden Policies can be served by a regular web server or, even
better, can be published inside of an OCI compliant registry.</p>
<p>Kubewarden Policies can be stored inside of an OCI compliant registry as
<a href="https://github.com/opencontainers/artifacts">OCI artifacts</a>.</p>
<h1><a class="header" href="#quick-start" id="quick-start">Quick Start</a></h1>
<p>The Kubewarden stack is made of the following components:</p>
<ul>
<li>An arbitrary number of <code>ClusterAdmissionPolicy</code> resources: this is how policies
are defined inside of Kubernetes</li>
<li>A Deployment of Kubewarden <code>policy-server</code>: this component loads all the
policies defined by the administrators and evaluates them</li>
<li>A Deployment of <code>kubewarden-controller</code>: this is the controller that monitors
the <code>AdmissionPolicy</code> resources and interacts with the Kubewarden <code>policy-server</code></li>
</ul>
<h2><a class="header" href="#install" id="install">Install</a></h2>
<p>The Kubewarden stack can be deployed using a helm chart:</p>
<pre><code class="language-console">helm repo add kubewarden https://charts.kubewarden.io
helm install --namespace kubewarden --create-namespace kubewarden-controller kubewarden/kubewarden-controller
</code></pre>
<p>This will install <code>kubewarden-controller</code> on the Kubernetes cluster in the default
configuration and will register the <code>AdmissionPolicy</code> Custom Resource. The
components of the Kubewarden stack will be deployed inside of a Kubernetes
Namespace called <code>kubewarden</code>.</p>
<p>The default configuration values should be good enough for the majority of
deployments, all the options are documented <a href="https://charts.kubewarden.io/#configuration">here</a>.</p>
<p>The Kubewarden Policy Server is completely managed by the kubewarden-controller.</p>
<h2><a class="header" href="#kubewarden-policies" id="kubewarden-policies">Kubewarden Policies</a></h2>
<p>Enforcing policies is by far the most common operation a Kubernetes
administrator will perform. You can declare as many policies as you want,
targeting any kind of Kubernetes resource and type of operation that can be
done against them.</p>
<p>The <code>ClusterAdmissionPolicy</code> resource is the core of the Kubewarden stack: this is
how validating policies are defined.</p>
<pre><code class="language-yaml">apiVersion: kubewarden.io/v1alpha1
kind: ClusterAdmissionPolicy
metadata:
  name: privileged-pods
spec:
  module: registry://ghcr.io/kubewarden/policies/psp-capabilities:v0.1.1
  resources:
  - pods
  operations:
  - CREATE
  - UPDATE
  mutating: true
  settings:
    allowed_capabilities:
    - CHOWN
    required_drop_capabilities:
    - NET_ADMIN
</code></pre>
<p>This is a quick overview of the attributes of the <code>ClusterAdmissionPolicy</code> resource:</p>
<ul>
<li><code>module</code>: this is the location of the Kubewarden policy, several schemas are
supported.
<ul>
<li><code>registry</code>: download from an <a href="https://github.com/opencontainers/artifacts">OCI artifacts</a>
compliant container registry</li>
<li><code>http</code>, <code>https</code>: download from a regular HTTP(s) server</li>
<li><code>file</code>: load the module from the local filesystem</li>
</ul>
</li>
<li><code>resources</code>: types of resources evaluated by the policy</li>
<li><code>operations</code>: what operations for the previously given types should
be forwarded to this admission policy by the API server for
evaluation.</li>
<li><code>mutating</code>: a boolean value that must be set to <code>true</code> for policies that can
mutate incoming requests.</li>
<li><code>settings</code> (optional): a free-form object that contains the policy
configuration values.</li>
<li><code>failurePolicy</code> (optional): how unrecognized errors and timeout errors from
the policy are handled. Allowed values are <code>Ignore</code> or <code>Fail</code>. <code>Ignore</code> means
that an error calling the webhook is ignored and the API request is allowed
to continue. <code>Fail</code> means that an error calling the webhook causes the
admission to fail and the API request to be rejected.
The default behaviour is <code>Fail</code>.</li>
</ul>
<p>The complete documentation of this Custom Resource can be found
<a href="https://github.com/kubewarden/kubewarden-controller/blob/main/docs/crds/README.asciidoc">here</a>
or on
<a href="https://doc.crds.dev/github.com/kubewarden/kubewarden-controller">docs.crds.dev</a>.</p>
<blockquote>
<p><strong>NOTE:</strong> ClusterAdmissionPolicy resources are registered with a <code>*</code> webhook
<code>scope</code>, which means that registered webhooks will be forwarded all
requests matching the given <code>resources</code> and <code>operations</code> -- either
namespaced (in any namespace), or cluster-wide resources.</p>
</blockquote>
<blockquote>
<p><strong>NOTE:</strong> The <code>ClusterAdmissionPolicy</code> resource is cluster-wide. There are
plans to also provide a namespaced version that will only impact
registered namespaced resources on its own namespace.</p>
</blockquote>
<h2><a class="header" href="#enforce-your-first-policy" id="enforce-your-first-policy">Enforce your first policy</a></h2>
<p>We will use the <a href="https://github.com/kubewarden/pod-privileged-policy"><code>pod-privileged</code> policy</a>.
This policy prevents the creation of privileged containers inside of a Kubernetes cluster.</p>
<p>Let's define a <code>ClusterAdmissionPolicy</code> for that:</p>
<pre><code class="language-console">kubectl apply -f - &lt;&lt;EOF
apiVersion: kubewarden.io/v1alpha1
kind: ClusterAdmissionPolicy
metadata:
  name: privileged-pods
spec:
  module: registry://ghcr.io/kubewarden/policies/pod-privileged:v0.1.1
  resources:
  - pods
  operations:
  - CREATE
  - UPDATE
EOF
</code></pre>
<p>This will produce the following output:</p>
<pre><code class="language-console">clusteradmissionpolicy.kubewarden.io/privileged-pods created
</code></pre>
<p>Defining the <code>ClusterAdmissionPolicy</code> will lead to a rollout of the Kubewarden Policy
Server Deployment. Once the new policy is ready to be served, the <code>kubewarden-controller</code>
will register a <a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.20/#validatingwebhookconfiguration-v1-admissionregistration-k8s-io">ValidatingWebhookConfiguration</a>
object.</p>
<p>Once all the instances of <code>policy-server</code> are ready, the
<code>ValidatingWebhookConfiguration</code> will be visible:</p>
<pre><code class="language-console">$ kubectl get validatingwebhookconfigurations.admissionregistration.k8s.io
NAME              WEBHOOKS   AGE
privileged-pods   1          9s
</code></pre>
<p>Let's try to create a Pod with no privileged containers:</p>
<pre><code class="language-console">kubectl apply -f - &lt;&lt;EOF
apiVersion: v1
kind: Pod
metadata:
  name: unprivileged-pod
spec:
  containers:
    - name: nginx
      image: nginx:latest
EOF
</code></pre>
<p>This will produce the following output, which means the Pod was successfully
created:</p>
<pre><code class="language-console">pod/unprivileged-pod created
</code></pre>
<p>Now, let's try to create a pod with at least one privileged container:</p>
<pre><code class="language-console">kubectl apply -f - &lt;&lt;EOF
apiVersion: v1
kind: Pod
metadata:
  name: privileged-pod
spec:
  containers:
    - name: nginx
      image: nginx:latest
      securityContext:
          privileged: true
EOF
</code></pre>
<p>This time the creation of the Pod will be blocked, with the following message:</p>
<pre><code class="language-console">Error from server: error when creating &quot;STDIN&quot;: admission webhook &quot;privileged-pods.kubewarden.admission&quot; denied the request: User 'minikube-user' cannot schedule privileged containers
</code></pre>
<h2><a class="header" href="#uninstall" id="uninstall">Uninstall</a></h2>
<p>As a first step remove all the <code>ClusterAdmissionPolicy</code> resources you have created.
This can be done with the following command:</p>
<pre><code class="language-shell">kubectl delete --all clusteradmissionpolicies.kubewarden.io
</code></pre>
<p>Then wait for the for the <code>kubewarden-controller</code> to remove all the
Kubernetes <code>ValidatingWebhookConfiguration</code> and the <code>MutatingWebhookConfiguration</code>
resources it created.</p>
<p>This can be monitored with the following command:</p>
<pre><code class="language-shell">kubectl get validatingwebhookconfigurations.admissionregistration.k8s.io -l &quot;kubewarden&quot; &amp;&amp; \
kubectl get mutatingwebhookconfigurations.admissionregistration.k8s.io -l &quot;kubewarden&quot;
</code></pre>
<p>If these resources are not automatically removed, you can do
remove them manually by using the following command:</p>
<pre><code class="language-shell">kubectl delete -l &quot;kubewarden&quot; validatingwebhookconfigurations.admissionregistration.k8s.io &amp;&amp; \
kubectl delete -l &quot;kubewarden&quot; mutatingwebhookconfigurations.admissionregistration.k8s.io
</code></pre>
<p>Finally you can uninstall the Helm chart:</p>
<pre><code class="language-shell">helm uninstall kubewarden-controller
</code></pre>
<p>Once this is done you can remove the Kubernetes namespace that was used to deploy
the Kubewarden stack:</p>
<pre><code class="language-shell">kubectl delete namespace kubewarden
</code></pre>
<p>This will delete all the resources that were created at runtime by the <code>kubewarden-controller</code>,
like the <code>policy-server</code> Deployment.</p>
<blockquote>
<p><strong>Note well:</strong> it's extremely important to remove the <code>ValidatingWebhookConfiguration</code>
and <code>MutatingWebhookConfiguration</code> resources <strong>before</strong> the
<code>policy-server</code> Deployment. Otherwise the Kubernetes
API server will continuously face timeout errors while trying to evaluate the
incoming requests.</p>
<p>By default the <code>ValidatingWebhookConfiguration</code> and <code>MutatingWebhookConfiguration</code>
resources created by Kubewarden have <code>policyFailure</code>
set to <code>Fail</code>, which will cause all these incoming requests to be rejected.</p>
<p><strong>This could bring havoc on your cluster.</strong></p>
</blockquote>
<h2><a class="header" href="#wrapping-up" id="wrapping-up">Wrapping up</a></h2>
<p>As we have seen, the <code>ClusterAdmissionPolicy</code> resource is the core type that
a cluster operator has to manage, the rest of the resources needed to
run the policies and configure them will be taken care of
automatically by the <code>kubewarden-controller</code> project.</p>
<h1><a class="header" href="#testing-policies" id="testing-policies">Testing Policies</a></h1>
<p>This section covers the topic of testing Kubewarden Policies. There are two possible
personas interested in testing policies:</p>
<ul>
<li>As a policy author: you're writing a Kubewarden Policy and you want to ensure
your code behaves the way you expect.</li>
<li>As an end user: you found a Kubewarden Policy and you want to tune/test the policy
settings before deploying it, maybe you want to keep testing these settings
inside of your CI/CD pipelines,...</li>
</ul>
<h1><a class="header" href="#kubewarden-policy-authors" id="kubewarden-policy-authors">Kubewarden Policy authors</a></h1>
<p>Kubewarden Policies are regular programs compiled as WebAssembly. As with any kind
of program, it's important to have a good test coverage.</p>
<p>Policy authors can leverage the testing frameworks and tools of their language
of choice to verify the behaviour of their policies.</p>
<p>As an example, you can take a look at these Kubewarden policies:</p>
<ul>
<li><a href="https://github.com/kubewarden/pod-privileged-policy">pod-privileged-policy</a>: this
is a Kubewarden Policy written using <a href="https://www.assemblyscript.org/">AssemblyScript</a>.</li>
<li><a href="https://github.com/kubewarden/pod-toleration-policy">pod-toleration-policy</a>: this
is a Kubewarden Policy written using <a href="https://www.rust-lang.org/">Rust</a>.</li>
</ul>
<p>Both policies have integrated test suites built using the regular testing libraries
of Rust and AssemblyScript.</p>
<p>Both projectes also rely on GitHub actions to implement their CI pipelines.</p>
<h1><a class="header" href="#end-users" id="end-users">End users</a></h1>
<p>Aside from the approach of testing policy logic with the tools that
your language toolchain already provides, Kubewarden has a dedicated
project for testing policies:
<a href="https://github.com/kubewarden/policy-server/tree/main/crates/policy-testdrive"><code>policy-testdrive</code></a>.</p>
<p>The concept of <code>policy-testdrive</code> is quite simple from a user
point of view. You have to provide:</p>
<ol>
<li>The Wasm file providing the policy to be tested. The file is specified through
the <code>--policy</code> argument. At this  time you can only load files in the local
filesystem.</li>
<li>A file containing the admission request object to be evaluated by
the policy. This is provided via the <code>--request-file</code> argument.</li>
<li>The policy settings to be used at evaluation time, they can be provided
via <code>--settings</code> flag. The flag takes a JSON blob as parameter.</li>
</ol>
<h2><a class="header" href="#install-1" id="install-1">Install</a></h2>
<p>You can install the <code>policy-testdrive</code> with Rust's <code>cargo</code>
package manager:</p>
<pre><code class="language-console">cargo install --git https://github.com/kubewarden/policy-server/crates/policy-testdrive.git --branch main
</code></pre>
<p>You should now have a <code>policy-testdrive</code> executable in your
<code>$PATH</code>:</p>
<pre><code class="language-console">$ which policy-testdrive
~/.cargo/bin/policy-testdrive
</code></pre>
<h2><a class="header" href="#quickstart" id="quickstart">Quickstart</a></h2>
<h3><a class="header" href="#prerequisites" id="prerequisites">Prerequisites</a></h3>
<p>We will use <a href="https://github.com/engineerd/wasm-to-oci"><code>wasm-to-oci</code></a>
to download a Kubewarden Policy published on a Container registry.</p>
<p>Pre-built binaries of <code>wasm-to-oci</code>can be downloaded from the project's
<a href="https://github.com/engineerd/wasm-to-oci/releases">GitHub Releases page</a>.</p>
<h3><a class="header" href="#obtain-a-kubewarden-policy" id="obtain-a-kubewarden-policy">Obtain a Kubewarden policy</a></h3>
<p>We will download the 
<a href="https://github.com/kubewarden/pod-privileged-policy">pod-privileged-policy</a>:</p>
<pre><code class="language-console">wasm-to-oci pull ghcr.io/kubewarden/policies/pod-privileged:v0.1.1
</code></pre>
<p>This will produce the following output:</p>
<pre><code class="language-console">INFO[0001] Pulled: ghcr.io/kubewarden/policies/pod-privileged:v0.1.1
INFO[0001] Size: 21769
INFO[0001] Digest: sha256:2d31248b45c51efbab5cb88b47ed5d6cff7611158591dbf8974e3c26589891f9
</code></pre>
<p>This should have created a <code>module.wasm</code> file in the current directoy.</p>
<h3><a class="header" href="#create-admissionreview-requests" id="create-admissionreview-requests">Create <code>AdmissionReview</code> requests</a></h3>
<p>We have to create some files holding the <code>AdmissionReview</code> objects that
will be evaluated by the policy.</p>
<p>Let's create a file named <code>unprivileged-pod-req.json</code> with the following
contents:</p>
<pre><code class="language-json">{
  &quot;kind&quot;: {
    &quot;kind&quot;: &quot;Pod&quot;,
    &quot;version&quot;: &quot;v1&quot;
  },
  &quot;object&quot;: {
    &quot;metadata&quot;: {
      &quot;name&quot;: &quot;unprivileged-pod&quot;
    },
    &quot;spec&quot;: {
      &quot;containers&quot;: [
        {
          &quot;image&quot;: &quot;nginx&quot;,
          &quot;name&quot;: &quot;unprivileged-container&quot;
        }
      ]
    }
  },
  &quot;operation&quot;: &quot;CREATE&quot;,
  &quot;requestKind&quot;: {&quot;version&quot;: &quot;v1&quot;, &quot;kind&quot;: &quot;Pod&quot;},
  &quot;userInfo&quot;: {
    &quot;username&quot;: &quot;alice&quot;,
    &quot;uid&quot;: &quot;alice-uid&quot;,
    &quot;groups&quot;: [&quot;system:authenticated&quot;, &quot;devops-guild&quot;, &quot;agile-guild&quot;]
  }
}
</code></pre>
<p>This request has been made by the user <code>alice</code> who belongs to the following
groups: <code>system:authenticated</code>, <code>devops-guild</code> and <code>agile-guild</code>.
All these informations can be found inside of the <code>userInfo</code> map.</p>
<p>Let's create a file named <code>privileged-pod-req.json</code> with the following
contents:</p>
<pre><code class="language-json">{
  &quot;kind&quot;: {
    &quot;kind&quot;: &quot;Pod&quot;,
    &quot;version&quot;: &quot;v1&quot;
  },
  &quot;object&quot;: {
    &quot;metadata&quot;: {
      &quot;name&quot;: &quot;privileged-pod&quot;
    },
    &quot;spec&quot;: {
      &quot;containers&quot;: [
        {
          &quot;image&quot;: &quot;nginx&quot;,
          &quot;name&quot;: &quot;privileged-container&quot;,
          &quot;securityContext&quot;: {
            &quot;privileged&quot;: true
          }
        }
      ]
    }
  },
  &quot;operation&quot;: &quot;CREATE&quot;,
  &quot;requestKind&quot;: {&quot;version&quot;: &quot;v1&quot;, &quot;kind&quot;: &quot;Pod&quot;},
  &quot;userInfo&quot;: {
    &quot;username&quot;: &quot;alice&quot;,
    &quot;uid&quot;: &quot;alice-uid&quot;,
    &quot;groups&quot;: [&quot;system:authenticated&quot;, &quot;devops-guild&quot;, &quot;agile-guild&quot;]
  }
}
</code></pre>
<p>This request is coming from the very same user <code>alice</code> show before.</p>
<blockquote>
<p><strong>Note well:</strong> these are stripped down <code>AdmissionReview</code> objects, we left
only the fields that are relevant to our policy.</p>
</blockquote>
<h3><a class="header" href="#test-the-policy" id="test-the-policy">Test the policy</a></h3>
<p>Now we can use <code>policy-testdrive</code> to test both requests:</p>
<pre><code class="language-console">policy-testdrive --policy module.wasm --request-file unprivileged-pod-req.json
</code></pre>
<p>The policy will accept the request and produce the following output:</p>
<pre><code class="language-console">ValidationResponse { accepted: true, message: Some(&quot;&quot;), code: None }
</code></pre>
<p>Whereas if we evaluate the privileged pod request:</p>
<pre><code class="language-console">policy-testdrive --policy module.wasm --request-file privileged-pod-req.json
</code></pre>
<p>The policy will reject the request and produce the following output:</p>
<pre><code class="language-console">ValidationResponse { accepted: false, message: Some(&quot;User \'alice\' cannot schedule privileged containers&quot;), code: None }
</code></pre>
<p>Both times we did a test drive of the policy <strong>without</strong> providing any kind of
setting. As the <a href="https://github.com/kubewarden/pod-privileged-policy#configuration">policy's documentation</a>
states, this results in preventing all the users to create privileged Pods.</p>
<p>We can change the default behaviour and allow members of the <code>devops-guild</code>
group to create privileged Pods. This can be done by setting the <code>trusted_groups</code>
value of the policy:</p>
<pre><code class="language-console">policy-testdrive --policy module.wasm \
  --request-file privileged-pod-req.json \
  --settings '{&quot;trusted_groups&quot;: [&quot;administrators&quot;, &quot;devops-guild&quot;]}'
</code></pre>
<p>This time the request is accepted:</p>
<pre><code class="language-console">ValidationResponse { accepted: true, message: Some(&quot;&quot;), code: None }
</code></pre>
<p>That happens because the request is coming from the user <code>alice</code>, who is
a member of the <code>devops-guild</code> group.</p>
<h2><a class="header" href="#wrapping-up-1" id="wrapping-up-1">Wrapping up</a></h2>
<p>Testing Kubewarden Policies is extremely important.</p>
<p>As a Kubewarden Policy author you can leverage the testing frameworks of your favorite
programming language and combine it with the CI systems of your choice to
ensure your code behaves as expected.</p>
<p>As a Kubewarden Policy end user you can use <code>policy-testdrive</code> to test
policies and their tuning outside of Kubernetes.</p>
<h1><a class="header" href="#writing-policies" id="writing-policies">Writing Policies</a></h1>
<p>Kubewarden policies can be written using any kind of language capable of building
<a href="https://webassembly.org/">Wasm</a> binaries and that supports <a href="https://github.com/wapc">waPC</a> guest SDK.</p>
<blockquote>
<p><strong>Note well:</strong> currently Kubewarden supports only Validating Admission Webhooks,
Mutating ones are not yet implemented.</p>
</blockquote>
<h2><a class="header" href="#writing-a-validation-policy" id="writing-a-validation-policy">Writing a validation policy</a></h2>
<p>The Kubewarden policy server receives
<a href="https://godoc.org/k8s.io/api/admission/v1#AdmissionReview"><code>AdmissionReview</code></a>
objects from the Kubernetes API server. It then forwards the value of
the <code>request</code> (of type
<a href="https://godoc.org/k8s.io/api/admission/v1#AdmissionRequest"><code>AdmissionRequest</code></a>
key to the policy to be evaluated.</p>
<p>The policy has to evaluate the <code>request</code> and state whether it should be
accepted or not. When the request is rejected, the policy must provide the
explanation message that is going to be shown to the end user.</p>
<p>By convention of the <code>policy-server</code> project, the guest has to expose
a function named <code>validate</code>, exposed through the waPC guest SDK, so
that the <code>policy-server</code> (waPC host) can invoke it.</p>
<p>The <code>validate</code> function receives a <code>ValidationRequest</code> object serialized as JSON and
returns a <code>ValidationResponse</code> object serialized as JSON. </p>
<h3><a class="header" href="#the-validationrequest-object" id="the-validationrequest-object">The <code>ValidationRequest</code> object</a></h3>
<p>The <code>ValidationRequest</code> is a simple JSON object that looks like that:</p>
<pre><code class="language-json">{
  &quot;request&quot;: &lt;AdmissionReview.request data&gt;
  &quot;settings&quot;: {
     // your policy configuration
  }
}
</code></pre>
<h3><a class="header" href="#the-validationresponse-object" id="the-validationresponse-object">The <code>ValidationResponse</code> object</a></h3>
<p>The <code>ValidationResponse</code> object is a simple JSON object like the
following:</p>
<pre><code class="language-json">{
  &quot;accepted&quot;: &lt;boolean&gt;, // mandatory
  &quot;message&quot;: &lt;string&gt;,   // optional, ignored if accepted - recommended for rejections
  &quot;code&quot;: &lt;integer&gt;      // optional, ignored if accepted
}
</code></pre>
<p>The <code>message</code> and <code>code</code> attributes can be specified when the request
is not accepted. <code>message</code> is a free form textual error. <code>code</code>
represents an HTTP error code.</p>
<p>If the request is accepted, <code>message</code> and <code>code</code>
values will be ignored by the Kubernetes API server if they are
present.</p>
<p>If <code>message</code> and/or <code>code</code> are provided, and the request is not
accepted, the Kubernetes API server will forward this information as
part of the body of the error returned to the Kubernetes API server
client that issued the rejected request.</p>
<h2><a class="header" href="#supported-lanauges" id="supported-lanauges">Supported lanauges</a></h2>
<p>Languages currently exposing a waPC guest SDK are:</p>
<ul>
<li><a href="https://github.com/wapc/as-guest">AssemblyScript</a></li>
<li><a href="https://github.com/wapc/wapc-guest-rust">Rust</a></li>
<li><a href="https://github.com/wapc/wapc-guest-tinygo">TinyGo</a></li>
<li><a href="https://github.com/wapc/wapc-guest-zig">Zig</a></li>
<li><a href="https://github.com/flavio/wapc-guest-swift">Swift</a></li>
</ul>
<p>The list of languages that can produce Wasm modules is continuously evolving.
<a href="https://github.com/appcypher/awesome-wasm-langs">This page</a> provides a
nice overview.</p>
<p>It's possible to check what languages support waPC guest by searching
on the <a href="https://github.com/wapc?q=guest&amp;type=&amp;language=">official github
group</a>.</p>
<h1><a class="header" href="#distributing-policies" id="distributing-policies">Distributing Policies</a></h1>
<p>Kubewarden policies are Wasm binaries that are evaluated by the
Kubewarden Policy Server.</p>
<p>The Kubewarden policy server can load policies from these
sources:</p>
<ul>
<li>Local filesystem</li>
<li>HTTP(s) server</li>
<li>OCI compliant registry like <a href="https://github.com/distribution/distribution">distribution</a>
and other container registries (GitHub container registry, Azure Container
Registry, Amazon ECR, Google Container Registry, ...)</li>
</ul>
<p>We think distributing Kubewarden policies via a regular OCI compliant
registry is the best choice. Container registries are basically a
mandatory requirement for any Kubernetes cluster. Having a single
place to store, and secure, all the artifacts required by a cluster
can be really handy.</p>
<h1><a class="header" href="#pushing-policies-to-an-oci-compliant-registry" id="pushing-policies-to-an-oci-compliant-registry">Pushing policies to an OCI compliant registry</a></h1>
<p>The <a href="https://github.com/opencontainers/artifacts">OCI Artifacts</a>
specification allows to store any kind of binary blob inside of a
regular OCI compliant container registry.</p>
<p>The target OCI compliant registry <strong>must support artifacts</strong> in order
to successfully push a Kubewarden Policy to it.</p>
<p>The <a href="https://github.com/engineerd/wasm-to-oci"><code>wasm-to-oci</code></a> command line tool
can be used to push a Kubewarden Policy to an OCI compliant registry.</p>
<p>Pushing a policy can be done in this way:</p>
<pre><code class="language-bash">$ wasm-to-oci push pod-runtime-class-policy.wasm \
              &lt;oci-registry&gt;/kubewarden-policies/pod-runtime-class-policy:v0.0.1
</code></pre>
<p>The policy can then be referenced from the Kubewarden Policy Server as
<code>registry://&lt;oci-registry&gt;/kubewarden-policies/pod-runtime-class-policy:v0.0.1</code>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
